<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>dalle2</title>
<base href="http://adityaramesh.com/" target="_self"/>
<link href="css/reset.css" rel="stylesheet"/>
<link href="css/tufte.css" rel="stylesheet"/>
<link href="css/latex.css" rel="stylesheet"/>
<link href="css/header_footer.css" rel="stylesheet"/>
<link href="css/table.css" rel="stylesheet"/>
<link href="css/tufte_pandoc_compat.css" rel="stylesheet"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full" type="text/javascript"></script>
</head>
<body>
<header>
<nav>
<a href="about.html">About</a>
<a href="index.html">Posts</a>
</nav>
</header>
<article>
<section class="level1" id="how-dalle-2-works">
<h1>How DALL·E 2 Works</h1>
<p><label class="margin-toggle" for="sidenote-1">⊕</label><input class="margin-toggle" id="sidenote-1" type="checkbox"/><span class="marginnote"><img src="posts/dalle2/images/variations.jpg"/> Figure 1: variations from DALL·E 2 on a blackboard doodle by Lei Pan. The original doodle is in the center, and the generated variations are displayed around it.</span> <a href="https://openai.com/dall-e-2">DALL·E 2</a> is a system for text-to-image generation developed <a href="https://arxiv.org/abs/2204.06125">by my coauthors and me</a> at <a href="https://openai.com">OpenAI.</a> When prompted with a caption, the system will attempt to generate a novel image from scratch that matches it. It also has additional capabilities like:</p>
<ul>
<li><strong>Inpainting:</strong> perform edits to an image using language;</li>
<li><strong>Variations (Figure 1):</strong> generate new images that share the same essence as a given reference image, but differ in how the details are put together; and</li>
<li><strong>Text diffs (Figure 4):</strong> transform any aspect of an image using language.</li>
</ul>
<p>The system underlying DALL·E 2, which we call unCLIP, is based on two key technologies: <a href="https://openai.com/blog/clip/">CLIP</a> and <a href="https://arxiv.org/abs/2006.11239">diffusion</a>. As stated in the blog, CLIP is a model that “efficiently learns visual concepts from natural language supervision”. Diffusion is a technique to train a generative model for images by learning to undo the steps of a fixed corruption process. We briefly describe both of these technologies next.</p>
<p><label class="margin-toggle" for="sidenote-2">⊕</label><input class="margin-toggle" id="sidenote-2" type="checkbox"/><span class="marginnote"><img src="posts/dalle2/images/clip.jpg"/> Figure 2: illustration of the contrastive training objective for CLIP. During each step of training, CLIP receives <span class="math inline">\(N = 32{,}786\)</span> images and their corresponding captions. From these, we form <span class="math inline">\(N\)</span> matching image-caption pairs (corresponding to the diagonal elements of the matrix in the illustration), and <span class="math inline">\(N (N - 1)\)</span> pairs of mismatching captions and images (corresponding to the off-diagonal elements).<br/><br/></span> CLIP consists of two neural networks – a text encoder and an image encoder – that are trained on a large, diverse collection of image-text pairs. Each encoder maps its input to a point on a globe (known as an <em>embedding</em>) that functions as a “concept space” shared by both modalities. During each step of training, CLIP receives a list of images and a corresponding list of captions that describe them. Using this data, we can form two types of image-text pairs: a <em>matching</em> pair, in which an image is paired up with its corresponding caption, and a <em>mismatching</em> pair, in which an image is paired up with any other caption. The encoders are trained to map the matching pairs to nearby points on this globe, and mismatching pairs to distant points.</p>
<p>This simple training objective<label class="margin-toggle sidenote-number" for="sidenote-3"></label><input class="margin-toggle" id="sidenote-3" type="checkbox"/><span class="sidenote">Known as “contrastive training” in machine learning.</span> encourages CLIP to learn about all of the features of an image that people are likely to write about online. These features include things like which objects are present, the aesthetic style, the colors and materials that are used, and so on. By contrast, CLIP is typically <em>not</em> incentivized to preserve information about the relative positions of objects, or information about which attributes apply to which objects. CLIP would therefore have a hard time distinguishing between, say, an image of a red cube on top of a blue cube and another image in which the positions of the two objects are swapped. The reason for this is the nature of the CLIP training objective: CLIP is only incentivized to learn the features of an image that are sufficient to match it up with the correct caption (as opposed to any of the others in the list). Unless it receives a counterexample (i.e., a caption that mentions a blue cube on top of a red cube), CLIP will not learn to preserve information about the objects’ relative positions.</p>
<p><label class="margin-toggle" for="sidenote-4">⊕</label><input class="margin-toggle" id="sidenote-4" type="checkbox"/><span class="marginnote"><img src="posts/dalle2/images/diffusion.gif"/> Figure 3: illustration of the process used to generate a new image with the diffusion model, created by <a href="https://aqnichol.com">Alex Nichol.</a><br/><br/></span> A diffusion model is trained to undo the steps of a fixed corruption process. Each step of the corruption process adds a small amount of noise<label class="margin-toggle sidenote-number" for="sidenote-5"></label><input class="margin-toggle" id="sidenote-5" type="checkbox"/><span class="sidenote">Specifically, gaussian noise.</span> to an image, which erases some of the information in it. After the final step, the image becomes indistinguishable from pure noise. The diffusion model is trained to reverse this process, and in doing so learns to regenerate what might have been erased in each step. To generate an image from scratch, we start with pure noise and suppose that it was the end result of the corruption process applied to a real image. Then, we repeatedly apply the model to reverse each step of this hypothetical corruption process. This gradually makes the image more and more realistic, eventually yielding a pristine, noiseless image.</p>
<p>DALL·E 2 generates images in a two-stage process, first by generating the “gist” of an image and then by filling in the remaining details to obtain a realistic image. In the first stage, a model which we call the prior generates the CLIP image embedding (intended to describe the “gist” of the image) from the given caption.<label class="margin-toggle sidenote-number" for="sidenote-6"></label><input class="margin-toggle" id="sidenote-6" type="checkbox"/><span class="sidenote">One might ask why this prior model is necessary: since the CLIP text encoder is trained to match the output of the image encoder, why not use the output of the text encoder as the “gist” of the image? The answer is that an infinite number of images could be consistent with a given caption, so the outputs of the two encoders will not perfectly coincide. Hence, a separate prior model is needed to “translate” the text embedding into an image embedding that could plausibly match it.</span> In the second stage, a diffusion model which we call unCLIP generates the image itself from this embedding. During each step of training, unCLIP receives both a corrupted version of the image it is trained to reconstruct, as well as the CLIP image embedding of the clean image. This model is called unCLIP because it effectively reverses the mapping learned by the CLIP image encoder. Since unCLIP trained to “fill in the details” necessary to produce a realistic image from the embedding, it will learn to model all of the information that CLIP deems irrelevant for its training objective and hence discards.</p>
<p>There’s a few reasons why it’s advantageous to use this two-stage sampling process, and we discuss two of them here.<label class="margin-toggle sidenote-number" for="sidenote-7"></label><input class="margin-toggle" id="sidenote-7" type="checkbox"/><span class="sidenote"><a href="https://arxiv.org/abs/2204.06125">Our paper</a> discusses further advantages of the two-stage sampling process.</span> Firstly, we can prioritize modeling the high-level semantics that make images meaningful to humans above other details. Images contain a lot of information, most of which is used to describe to fine-grained, imperceptible details. Only a relatively tiny sliver of this information is responsible for what makes images visually coherent and meaningful to us, and the CLIP image embedding captures much of it. Training a model directly on the CLIP image embedding allows us to focus on modeling these salient characteristics first, before filling in the details necessary to synthesize a realistic image in the second stage.</p>
<p><label class="margin-toggle" for="sidenote-8">⊕</label><input class="margin-toggle" id="sidenote-8" type="checkbox"/><span class="marginnote"><img src="posts/dalle2/images/house.gif"/> Figure 4: animation of text diff used to transform a Victorian house into a modern one. The transformation is determined by the captions “a victorian house”, which describes the architecture of the house, and “a modern house”, which describes how the architecture of the house should be changed.<br/><br/></span> The second reason is that CLIP’s multimodal embedding space allows us to apply “before and after” transformations to images using a technique that we call <em>text diffs</em>. In 2013, <a href="https://arxiv.org/abs/1310.4546">word2vec</a> showed that it is possible to obtain a “concept space” for text in which vector arithmetic becomes interpretable. For example, word2vec maps the word “queen” close to the result of computing <span class="math display">\[
    \textrm{“woman”} + \textrm{“king”} - \textrm{“man”},
\]</span> which makes it possible to complete analogies of the sort one might encounter in a standardized test. CLIP takes this a step further and allows us to perform arithmetic using <em>both</em> text and images, as in <span class="math display">\[
    \textrm{(image of victorian house)} + \textrm{“a modern house”} - \textrm{“a victorian house”}.
\]</span> Using unCLIP, we can translate points in CLIP’s concept space back into images and visually inspect the change that is taking place as we move the embedding of the image in the direction specified by the “before” caption (“a victorian house”) and the “after” caption (“a modern house”).<label class="margin-toggle sidenote-number" for="sidenote-9"></label><input class="margin-toggle" id="sidenote-9" type="checkbox"/><span class="sidenote">Concretely, let <span class="math inline">\(f_i\)</span> and <span class="math inline">\(f_t\)</span> denote the CLIP image and text encoders, respectively, and suppose that we have an image of a Victorian house contained in a file <code>house.png</code> which we would like to transform into a modern house. To do this, we first compute <span class="math display">\[
\begin{align}
z_{i0} &amp;= f_i(\texttt{house.png}), \\
z_{t0} &amp;= f_t(\textrm{“a photo of a victorian house”}), \\
z_{t1} &amp;= f_t(\textrm{“a photo of a modern house”}), \quad\textrm{and} \\
z_d &amp;= (z_{t1} - z_{t0}) / \|z_{t1} - z_{t0}\|,
\end{align}
\]</span> where <span class="math inline">\(z_d\)</span> is known as the <em>text diff vector.</em> Next, to transform the house, we rotate between the image embedding <span class="math inline">\(z_{i0}\)</span> and the text diff vector <span class="math inline">\(z_d\)</span> using <span class="math inline">\(z_{i1} = \operatorname{slerp}(z_{i0}, z_d, \theta)\)</span>. Finally, we synthesize an image from <span class="math inline">\(z_{i1}\)</span> using unCLIP. The animation shows the trajectory as <span class="math inline">\(\theta\)</span> is varied from 0 (which reconstructs the original image) to 0.50 (which results in a modernized version of the house).</span> The animation shows this trajectory, and provides us with visual confirmation that the image of a victorian house that we started out with is indeed being “modernized” as we might intuitively expect. Of course, text diffs are not limited to architecture: the transformation could be any “before and after” concept that can be expressed in language, which makes this a versatile and powerful tool.</p>
<p><em>Acknowledgments:</em> I’d like to thank Lei Pan, <a href="https://twitter.com/AravSrinivas/with_replies">Aravind Srinivas</a>, <a href="http://www.rewon.org">Rewon Child</a> and Justin Mao-Jones for their feedback on this blog. I’d also like to thank to my coauthors <a href="https://prafulladhariwal.com">Prafulla Dhariwal</a>, <a href="https://aqnichol.com">Alex Nichol</a>, <a href="http://caseychu.io">Casey Chu</a>, and <a href="https://twitter.com/markchen90?lang=en">Mark Chen</a>.</p>
</section>

</article>
<footer>
<hr/>
<div class="credits">
<span><a href="http://github.com/adityaramesh/tufte-blog">Tufte-Blog</a> uses
                    <a href="http://pandoc.org">Pandoc</a> with
                    <a href="http://github.com/edwardtufte/tufte-css">Tufte CSS</a> and
                    <a href="http://mathjax.org">MathJax.</a>
</span></div>
</footer>
</body>
</html>